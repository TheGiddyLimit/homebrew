import {execFile} from "node:child_process";
import {Um, Uf} from "5etools-utils";
import * as Ub from "./util-brew.js";
import fs from "fs";
import hasha from "hasha";

const _LOG_TAG = `TIMESTAMPS`;

const _UPDATE_TYPES = {
	NONE: 0,
	HASH: 1,
	TIMESTAMP: 2,
};


async function pUpdateDir (dir) {
	const promises = Uf.listJsonFiles(dir)
		.map(async file => {
			const fileData = Uf.readJSON(file, {isIncludeRaw: true});

			const hasMeta = !Ub.FILES_NO_META[file];
			if (!fileData.json._meta && hasMeta) {
				throw new Error(`File "${file}" did not have metadata!`);
			}
			if (!hasMeta) return;

			let updateType = _UPDATE_TYPES.NONE;

			// We hash the file *without* `_meta`, as `_meta` includes:
			//  - "dateAdded" and "dateLastModified", which we want to ignore for hashing for timestamp updates
			//  - the "_dateLastModifiedHash", which we want to ignore for hashing
			// Unfortunately this means that updating the `_meta` does not trigger a hash change, but this is an
			//   acceptable sacrifice for the rest of the system being simpler.
			const toHashObj = {...fileData.json};
			delete toHashObj._meta;
			const expectedHash = (await hasha.async(JSON.stringify(toHashObj))).slice(0, 10);

			if (!fileData.json._meta._dateLastModifiedHash) {
				updateType = _UPDATE_TYPES.HASH;
				fileData.json._meta._dateLastModifiedHash = expectedHash;
			} else if (expectedHash !== fileData.json._meta._dateLastModifiedHash) {
				// Grab the last commit timestamp from the log.
				// This is often a "junk" commit generated by cleaning (or indeed, timestamping) the file, but this is
				//   good enough.
				const dateLastModified = await new Promise((resolve, reject) => {
					execFile(
						"git",
						["log", "-1", `--format="%ad"`, file],
						{
							windowsHide: true,
						},
						(err, stdout, stderr) => {
							if (err) return reject(err);
							resolve(Math.round(new Date(stdout.trim()).getTime() / 1000));
						},
					);
				});

				if (fileData.json._meta.dateLastModified < dateLastModified) {
					updateType = _UPDATE_TYPES.TIMESTAMP;
					fileData.json._meta.dateLastModified = dateLastModified;
					fileData.json._meta._dateLastModifiedHash = expectedHash;
				}
			}


			if (updateType === _UPDATE_TYPES.NONE) return;

			const strContents = Ub.getCleanJson(fileData.json);

			await new Promise((resolve, reject) => {
				fs.writeFile(
					file,
					strContents,
					(err) => {
						if (err) return reject(err);
						resolve();
					},
				);
			});

			Um.info(
				_LOG_TAG,
				updateType === _UPDATE_TYPES.HASH
					? `\t- Updated "_dateLastModifiedHash" for "${file}"...`
					: `\t- Updated "dateLastModified" for "${file}"...`,
			);
		});

	await Promise.all(promises);
}


async function main () {
	await Uf.pRunOnDirs(
		async (dir) => {
			Um.info(_LOG_TAG, `Updating dateLastModified timestamps in dir "${dir}"...`);
			await pUpdateDir(dir);
		},
		{
			isSerial: true,
		},
	);
}

main().then(() => Um.info(_LOG_TAG, "Done!"));


